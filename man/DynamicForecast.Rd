% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DynamicForecast.R
\name{DynamicForecast}
\alias{DynamicForecast}
\alias{COVID19}
\title{Dynamic Forecast of Five Models and their Ensembles}
\usage{
DynamicForecast(Data, date, series, dyrima, Trend, Type, MaximumDate, x = 0,
x100 = 0, BREAKS = 0, ORIGIN = NULL, origin = "1970-01-01", Length = 0, ...)
}
\arguments{
\item{date}{A vector containing the dates for which the data is collected.
Must be the same length with \code{series}. The date must be in 'YYYY-MM-DD'.
If the data is monthly series, the recognized date format is the last day of
the month of the dataset e.g. 2021-02-28. If the data is a yearly series,
the recognized date format is the last day of the year of the data set e.g.
2020-12-31. There is no format for Quarterly data for now.}

\item{x}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}}

\item{series}{A vector containing observations for estimation and forecasting.
Must be the same length with \code{date}.}

\item{dyrima}{\strong{ARIMA} object of the \code{series} obtained from \code{auto.rima} in
forecast package.}

\item{x100}{vector of optional dataset that is to be added to the model for
forecasting. The modeling and forecasting is still done if not provided.
Must be the same length with \code{series}.}

\item{BREAKS}{A vector of numbers indicating points of breaks for estimation
of the spline models.}

\item{MaximumDate}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}. The date indicating
the maximum date (last date) in the data frame, meaning that forecasting
starts the next date following it. The date must be a recognized date
format. Note that for forecasting, the date origin is set to 1970-01-01.}

\item{Trend}{The type of trend. There are three options
\strong{Day, Month and Year}.}

\item{Type}{The type of response variable. There are two options
\strong{Continuous and Integer}. For integer variable, the forecasts are
constrained between the minimum and maximum value of the response variable.}

\item{Length}{The length for which the forecast would be made. If not given,
would default to the length of the dataset i.e. sample size.}

\item{origin}{default date origin which is \strong{1970-01-01} used to position
the date of data so that the forecasts are in tandem with the period of the
observations.}

\item{ORIGIN}{date origin of the dataset and if different from \strong{origin}
must be in the format \code{"YYYY-MM-DD"}. This is used to position the date of
the data to properly \code{date} the forecasts.}

\item{Data}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}. Now broken into three
vectors \code{date}, \code{series} and \code{x100}.}

\item{...}{Additional arguments that may be passed to the function.}
}
\value{
A list with the following components:
\item{\code{Spline without knots}}{The estimated spline model without the
breaks (knots).}
\item{\code{Spline with knots}}{The estimated spline model with the breaks
(knots).}
\item{\code{Smooth Spline}}{The smooth spline estimates.}
\item{\code{ARIMA}}{Estimated Auto Regressive Integrated Moving Average
model.}
\item{\code{Quadratic}}{The estimated quadratic polynomial model.}
\item{\code{Ensembled with equal weight}}{Estimated Ensemble model with
equal weight given to each of the models. To get this, the fitted values of
each of the models is divided by the number of models and summed together.}
\item{\code{Ensembled based on weight}}{Estimated Ensemble model based on
weight of each model. To do this, the fitted values of each model served as
independent variable and regressed against the trend with interaction among
the variables.}
\item{\code{Ensembled based on summed weight}}{Estimated Ensemble model
based on summed weight of each model. To do this, the fitted values of each
model served as independent variable and is regressed against the trend.}
\item{\code{Ensembled based on weight of fit}}{Estimated Ensemble model.
The fit of each model is measured by the rmse.}
\item{\code{Unconstrained Forecast}}{The forecast if the response variable
is continuous. The number of forecasts is equivalent to the length of the
dataset (equal days forecast).}
\item{\code{Constrained Forecast}}{The forecast if the response variable is
integer. The number of forecasts is equivalent to the length of the dataset
(equal days forecast).}
\item{\code{RMSE}}{Root Mean Square Error (rmse) for each forecast.}
\item{\code{Unconstrained forecast Plot}}{The combined plots of the
unconstrained forecasts using ggplot. }
\item{\code{Constrained forecast Plot}}{The combined plots of the
constrained forecasts using ggplot. }
\item{\code{Date}}{This is the date range for the forecast.}
\item{\code{Fitted plot}}{This is the plot of the fitted models.}
\item{\code{Estimated coefficients}}{This is the estimated coefficients of
the various models in the forecast.}
}
\description{
The function estimates, predict and forecast time series data with models,
and also make subset forecasts within the length of the entire trend of the
data. The recognized models are lm, smooth spline, polynomial splines with or
without knots, quadratic polynomial, and ARIMA. The robust output include
the models' estimates, time-varying forecasts and plots  based on themes
from ggplot. The main attraction of this function is the use of the newly
introduced \emph{equal number of trend to forecast from the model}.
The function takes \verb{daily, monthly and yearly data sets for now}.
}
\examples{
# library(readr)
# library(forecast)
# COVID19$Date <- zoo::as.Date(COVID19$Date, format = '\%m/\%d/\%Y')
#  #The date is formatted to R format
# LEN <- length(COVID19$Case)
# Dss <- seq(COVID19$Date[1], by = "day", length.out = LEN)
#  #data length for forecast
# ORIGIN = "2020-02-29"
# lastdayfo21 <- Dss[length(Dss)] # The maximum length # uncomment to run
# Data <- COVID19[COVID19$Date <= lastdayfo21 - 28, ]
# # desired length of forecast
# BREAKS <- c(70, 131, 173, 228, 274) # The default breaks for the data
# dyrima <- auto.arima(Data$Case)
# DynamicForecast(date = Data$Date, series = Data$Case, dyrima = dyrima,
# BREAKS = BREAKS, Trend = "Day", Length = 0, Type = "Integer", x100 = 0)
#
# lastdayfo21 <- Dss[length(Dss)]
# Data <- COVID19[COVID19$Date <= lastdayfo21 - 14, ]
# BREAKS = c(70, 131, 173, 228, 274)
# dyrima <- auto.arima(Data$Case)
# DynamicForecast(date = Data$Date, series = Data$Case, dyrima = dyrima,
# BREAKS = BREAKS , Trend = "Day", Length = 0, Type = "Integer", x100 = 0)
}
